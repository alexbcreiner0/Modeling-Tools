from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional
import os, importlib, inspect
import yaml
from tools.loader import load_presets
import re, copy
from widgets.PlotSettingsTab import PlotSettingsTab
from widgets.DemoSettingsTab import DemoSettingsTab
from widgets.GlobalSettingsTab import GlobalSettingsTab
from widgets.ControlSettingsTab import ControlSettingsTab
from widgets.ParamSettingsTab import ParamSettingsTab
from widgets.PresetSettingsTab import PresetSettingsTab
from widgets.ModelSettingsTab import ModelSettingsTab

from PyQt6 import (
    QtCore as qc,
    QtWidgets as qw,
    QtGui as qg
)
from tools.modelling_tools import list_subdirs, FlowSeq, flowseq_representer, _add_demo, resave_config
from paths import rpath
from widgets.common import FormSection, make_shortname

yaml.add_representer(FlowSeq, flowseq_representer, Dumper=yaml.SafeDumper)

class StatusBar(qw.QStatusBar):
    """QStatusBar that auto-clears messages after a timeout by default."""
    def show(self, msg: str, timeout_ms: int = 5000) -> None:
        self.showMessage(msg, timeout_ms)

class EditConfigDialog(qw.QDialog):

    configApplied = qc.pyqtSignal()

    def __init__(self, model: str = None, tab: int = 0, parent: Optional[qw.QWidget] = None):
        super().__init__(parent)
        self.setWindowTitle("Edit Config")
        self.resize(1300, 640)

        root = qw.QVBoxLayout(self)
        root.setContentsMargins(10, 10, 10, 10)
        root.setSpacing(10)

        body = qw.QHBoxLayout()
        body.setSpacing(12)
        root.addLayout(body, 1)

        nav_box = qw.QGroupBox("Settings and Utilities")
        nav_layout = qw.QVBoxLayout(nav_box)
        nav_layout.setContentsMargins(10, 10, 10, 10)
        nav_box.setSizePolicy(qw.QSizePolicy.Policy.Preferred, qw.QSizePolicy.Policy.Expanding)

        self.nav = qw.QListWidget()
        self.nav.setSpacing(2)
        self.nav.addItem("Global settings")
        self.nav.addItem("Models")
        self.nav.addItem("Parameters")
        self.nav.addItem("Presets")
        self.nav.addItem("Controls")
        self.nav.addItem("Plots")
        self.nav.addItem("Demos")

        self.status = StatusBar()
        self.status.setSizeGripEnabled(False)

        nav_layout.addWidget(self.nav, 1)
        body.addWidget(nav_box, 0)

        self.stack = qw.QStackedWidget()
        body.addWidget(self.stack, 1)

        self.page_global = GlobalSettingsTab(self)
        self.page_models = ModelSettingsTab(model, self)
        self.page_params = ParamSettingsTab(model, self)
        self.page_presets = PresetSettingsTab(model, self)
        self.page_controls = ControlSettingsTab(model, self)
        self.page_plots = PlotSettingsTab(model, self)
        self.page_demos = DemoSettingsTab(self)

        self._syncing_model = False

        self.stack.addWidget(self.page_global)
        self.stack.addWidget(self.page_models)
        self.stack.addWidget(self.page_params)
        self.stack.addWidget(self.page_presets)
        self.stack.addWidget(self.page_controls)
        self.stack.addWidget(self.page_plots)
        self.stack.addWidget(self.page_demos)

        self.page_plots.model_combo.currentTextChanged.connect(self._on_model_changed)
        self.page_controls.model_combo.currentTextChanged.connect(self._on_model_changed)
        self.page_params.availableParamsChanged.connect(self.page_controls.set_available_params)
        self.page_params.model_combo.currentTextChanged.connect(self._on_model_changed)
        self.page_presets.model_combo.currentTextChanged.connect(self._on_model_changed)
        self.page_models.newModelCreated.connect(self.page_demos.on_new_model_created)
        self.page_models.model_list.currentTextChanged.connect(self._on_model_changed)
        self.page_models.modelsChanged.connect(self._refresh_model_combos)

        bottom = qw.QHBoxLayout()
        root.addLayout(bottom, 0)

        # Put status bar in a container so it doesn't stretch weirdly
        status_wrap = qw.QWidget()
        status_wrap_layout = qw.QVBoxLayout(status_wrap)
        status_wrap_layout.setContentsMargins(0, 0, 0, 0)
        status_wrap_layout.addWidget(self.status)
        bottom.addWidget(status_wrap, 1)

        self.buttons = qw.QDialogButtonBox()
        self.btn_apply = self.buttons.addButton("Apply", qw.QDialogButtonBox.ButtonRole.ApplyRole)
        self.btn_save = self.buttons.addButton("Save", qw.QDialogButtonBox.ButtonRole.AcceptRole)
        self.btn_close = self.buttons.addButton(qw.QDialogButtonBox.StandardButton.Close)
        bottom.addWidget(self.buttons, 0)

        self.nav.currentRowChanged.connect(self.stack.setCurrentIndex)
        self.btn_close.clicked.connect(self.reject)
        self.btn_apply.clicked.connect(self._on_apply_clicked)
        self.btn_save.clicked.connect(self._on_save_clicked)

        self.stack.setCurrentIndex(tab)
        self.nav.setCurrentRow(tab)

        if model is not None:
            self._on_model_changed(model)


    def bootstrap(self, parent= None):
        if self.exec() == qw.QDialog.DialogCode.Accepted: # close once the acceptance flag is flagged (in the on_save method)
            return 1
        else:
            return 0

    def _on_apply_clicked(self) -> None:
        save_dir = self.page_global.edit_default_save_dir.text()
        self.page_demos.on_apply_clicked_demo(save_dir)
        self.page_plots.on_apply_clicked_plots()
        self.page_controls.on_apply_clicked_controls()
        self.page_params.on_apply_clicked_controls()
        self.page_presets.on_apply_clicked_presets()

        self.configApplied.emit()

    def _on_save_clicked(self) -> None:
        # You implement actual writing
        # self.save_data(self.data)
        self._on_apply_clicked()
        self.accept()

    def _refresh_models(self):
        models = list_subdirs(rpath("models"))
        return models

    # def _install_shortcuts(self) -> None:
    #     # Ctrl+1..4 to switch pages quickly
    #     for i in range(4):
    #         sc = qw.QShortcut(qc.QKeySequence(f"Ctrl+{i+1}"), self)
    #         sc.activated.connect(lambda i=i: self.nav.setCurrentRow(i))

    def _on_model_changed(self, model_name: str):
        if self._syncing_model:
            return

        self._syncing_model = True
        try:
            self.page_plots.set_model(model_name)
            self.page_controls.set_model(model_name)
            self.page_params.set_model(model_name)
            self.page_presets.set_model(model_name)
            self.page_models.set_model(model_name)
        finally:
            self._syncing_model = False

    def _refresh_model_combos(self) -> None:
        """Refresh model selectors in the per-model tabs.

        Triggered when the Models tab detects that the on-disk model list changed
        (e.g., after creating a new model).
        """
        for page in (self.page_plots, self.page_controls, self.page_params, self.page_presets):
            try:
                page._refresh_models()
            except Exception:
                pass

        # If current model disappeared, fall back to first available.
        try:
            models = self._refresh_models()
            if models:
                cur = None
                if getattr(self.page_plots, "model_combo", None) is not None:
                    cur = self.page_plots.model_combo.currentText().strip()
                if cur and cur in models:
                    return
                self._on_model_changed(models[0])
        except Exception:
            pass

if __name__ == "__main__":
    pass
